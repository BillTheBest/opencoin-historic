"""
ToDo:
    * TypeError
    * Test
    * Test Exceptions, too


DEFINITION:

    import RingTheory

    Given a ring R and two elements x and y. A generator d of the ideal

        dR = xR + yR

    is called "greatest common devider" (gcd) of x and y. It is a linear 
    combination of x and y and is unique up to a unit of R.

This definition covers some special cases like

        gcd(x,0) = x    
        gcd(0,0) = 0


Corollary

    If every ideal in R is generated by just one element (making R a 
    "principle ideal domain") the gcd always exists.


THEROREM:

    The domain of integers is a principle ideal domain.

"""


def eea(x,y):
    """
    In the case of R being the principle domain of integers, the Extended 
    Euklidian Algorithm (eea) calculates for any two integers x and y their 
    gcd as a linear combination:

        gcd(x,y) = a*x + b*y

    Our function returns (gcd,a,b) with gcd not being negative, e.g.

    >>> eea(84,120)
    (12, 3, -2)
    """

    # catch special cases of y==0
    if (x,y) == (0,0):
        (gcd,a,b) = (0, 0, 0)

    elif  y  ==  0:
        (gcd,a,b) = (x, 1, 0)

    else:
    # now the real thing
        (a,b)=(x,y)
        r = a%b
        FactorList=[]
        while r != 0:
            FactorList.append(-(a//b))
            (a,b)=(b,r)
            r = a%b

        if FactorList:
            (gcd,a,b) = (b, 1, FactorList.pop())
        else:
            # oh, special case of y being y a devider of x!
            (gcd,a,b) = (b, 0, 1)

        while FactorList:
            (a,b)=(b,b*FactorList.pop()+a)
            
    if gcd < 0: 
        (gcd,a,b) = (-gcd,-a,-b)

    return (gcd,a,b)


def gcd(x,y):
    """
    >>> gcd(2,3)
    1
    """

    return eea(x,y)[0]


def inverse(x,N):
    """
    The extended Euklidian algorithm is useful to invert integers in residue rings.
    Numbers are invertible iff they are coprime to the modulus.

    >>> inverse(107,224)
    67
    """

    if N == 0:   raise ValueError('Modulus must not be 0')
    (gcd,a,b) = eea(x,N)
    if gcd != 1: raise ValueError('Divisor not invertable because it is not coprime to modulus!')

    return a  # %N ?


def quotient(x,y,N):
    return x*inverse(y,N) % N

def divide(x,y,N):
    return x*inverse(y,N) % N


if __name__ == "__main__":
    from doctest import testmod
    testmod()
