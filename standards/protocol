OpenCoin 

#1 issuer setup

* issuer generates master key pair (pM,sM)

* issuer sets up "currency description document"

   {
     content part:
       opencoin standard version      http://opencoin.org/OpenCoinProtocol/1.0    (accidentally a URL of the Standard)
       currency identifier            http://opencent.net/OpenCent                (accidentally URL of this CDD)
       currency identifier (short)    OC
       issuer service location        opencoin://issuer.opencent.net:8002
       denominations                  1, 2, 5, 10, 20, 50, 100, 200, 500, 1000
       issuer public master key       .... 
   +
     signature over the content part, made with the issuers master secret key
   + 
     [signature over the content part, made with somebody's secret key, ...]
   }


* mint (regularily) creates keypairs (p[i],s[i]) for all denominations i, 
  sign(sM, (i, id(p[i])), p[i], coin_expires, key_not_before, key_not_after)
  
  (id() = hash())      (p herausnehmen???)

* issuer fires up issuer service at <opencoin://issuer.opencent.net:8002>



#2 wallet setup

* fetch "currency description document" from issuer


#3 wallet sends signing reuest to issuer

* Wallet: fetches current public minting keys for denomination

* Wallet: creates blank according to CDD:

  blank = {
      standard identifier             http://opencoin.org/OpenCoinProtocol/1.0
      currency identifier             http://opencent.net/OpenCent 
      denomination                    10
      key_id                          id(signing key)
      serial                          128bit random number (collision resistant)
  }


* Wallet: create random r, calculate 

    blind = blinding(r, blank)
 
  Keep (r, blank, blind) in mind. Send 

    request = ( (blind, key_id), [request_id] )

  to issuer service

* Issuer: checks, if key_id is current, otherwise rejct with "current key is #ID"

  Decides if request will be minted (e.g., payment not yet received), otherwise reject

  Issuer passes (maybe asynchronous) reuest to mint.

  Mint processes request (sings blind with key_id)

  Mint passes "signed blind"="blind coin" back to issuer 


#4 Wallet gets coin back

* Wallet asks issuer service "fetch_signed_blind request_id"

* Issuer passes signed blind to wallet or rejects (temporarily or finally)

* wallet checks if blind fits request id and if blind was correctly signed. 
  If not, delete blind and inform user (optional: inform issuer about error)
  (optional: if yes, inform issuer that he may delete the request)

* Wallet unblinds signed blind and yields coin  (or reblinds)

