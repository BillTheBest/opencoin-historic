OpenCoin 

ToDo
====
* do the stuff in ./TODO
* replace "coin" with "token"
* decide whether the protocol atoms are tokens or lists of tokens
* throw out reduntant "TRANSFER_TOKEN" explanatoins


How the wallet creates a coin and communicates with an issuer
=============================================================
 
#1 issuer setup

* issuer generates master key pair (ALG,pM,sM)

* issuer sets up "currency description document" = CDD (like a root certificate)

   {
     standard version             = http://opencoin.org/OpenCoinProtocol/1.0
     currency identifier          = http://opencent.net/OpenCent
     short currency identifier    = OC 
     issuer service location      = opencoin://issuer.opencent.net:8002
     denominations                = strlist(1, 2, 5, 10, 20, 50, 100, 200, 500, 1000)  #list of strings seperated by commas
     issuer cipher suite          = HASH-ALG, SIGN-ALG, BLINDING-ALG
     issuer public master key     = base64(pM)
     
     issuer                       = base64(hash(pM))
     base64(sig(sM,hash(content part)))
   }

   (question: is the "short currency identifier" needed?)
   (question: "not use after")
   (future: add additionial signatures, e.g. from wallet software vendors (set up in containers already))

* issuer publishes CDD at "currency identifier" URL

* mint (regularily) creates keypairs (pP,sP) for all denominations and id(p).
  Master key holder generates keys certificate

  {
    key identifier      = base64(hash(pP))
    currency identifier = http://opencent.net/OpenCent
    denomination        = denomination
    not_before          = TIME(...)
    key_not_after       = TIME(...)
    coin_not_after      = TIME(...)
    public key          = base64(pP)

    issuer              = base64(hash(pM))
    base64(sig(sM, hash(content part)))
  }

  
  Questions:
  * CDD? (What does this question mean?)

* issuer creates DSDB keypair (pD,sD)

  {
    key identifier   = base64(hash(pD))
    not_before       = TIME(...)
    not_after        = TIME(...)
    cipher           = ENCRYPTION-ALG
    public key       = base64(pD)

    issuer           = base64(hash(pM))
    signature        = base64(sig(sM, hash(content part)))

    signer           = base64(hash(pM))
    signature        = base64(sig(sM, hash(content part)))
  }   


* issuer fires up issuer service (=IS) at <opencoin://issuer.opencent.net:8002>



#2 wallet setup

* fetch "currency description document" from issuer


#3 wallet creates blanks

* Wallet: fetches current public minting keys for denomination

Wallet:
    MINTING_KEY_FETCH_DENOMINATION(denomination) or MINTING_KEY_FETCH_KEYID(key_id)
IS:
    MINTING_KEY_PASS(keycertificate) or MINTING_KEY_FAILURE(reason)

* Wallet: creates blank according to CDD:

  {
      standard identifier = http://opencoin.org/OpenCoinProtocol/1.0
      currency identifier = http://opencent.net/OpenCent 
      denomination        = denomination
      key identifier      = key_id(signing key)
      serial              = base64(128bit random number)
  }


* Wallet: create random r, calculate 

    blind = blinding(r, pub_minting_key, hash(blank))
 
  Calculate a collision-free random request ID (128 bit)

  Keep (r, blank, blind) in mind. 
  

#3.5 "TRANSFER_TOKEN": A generic wallet-issuer request

The atom for this transaction is a list of coins - if one of the coins /blanks
fail, the whole transaction fails.

* Send 

   TRANSFER_TOKEN_REQUEST( transaction_id, list_of_options, target, \
                            list_of_blinds, list_of_coins )

  to IS (issuer service), where 
  * transaction_id is a base64(random(128bit)) referencing this transaction
    e.g. for later resume after an abort. 
  * option may contain variable=value pairs like "JITM=mandatory".
  * target 
    * value(list_of_blinds) = value(list_of_coins): empty
    * value(list_of_blinds) > value(list_of_coins): payment reference
    * value(list_of_blinds) < value(list_of_coins): account reference

  For now, only 'pure' transactions are allowed, so one of these must 
  be empty:
  * target        : coin exchange (value(list_of_blinds) = value(list_of_coins))
  * list_of_coins : mint request
  * list_of_blinds: redemption

  If at least one of the blinds or coins is rejected, the issuer answers

    TRANSFER_TOKEN_REJECT( transaction_id, reason,
                           list( (blind1.key_id, reason1), ... ), \
                           list( (coin1.key_id,  reason1), ... )  )

  where "reason" may be some general failure like "500 minting not available".
  If the request is accepted with no delay, IS answers

    TRANSFER_TOKEN_ACCEPT( transaction_id, message, list_of_singed_blinds)

  (with list_of_singed_blinds empty if no minting was required)
  If minting was requested and acccepted but postponed, IS answers

    TRANSFER_TOKEN_DELAY( transaction_id, message )

  In this case, the wallet can fetch the signed blinds later by 

    TRANSFER_TOKEN_RESUME( transaction_id )


#4 wallet send minting request to issuer  

* Send [was: MINT_REQUEST]

    TRANSFER_TOKEN_REQUEST( transaction_id, list_of_options, target, \
                            list_of_blinds, (empty list) )

  to issuer service

* Issuer: if request will not be minted (e.g., "Bad Key ID" if the key_id
  is not current):

    TRANSFER_TOKEN_REJECT( transaction_id, reason,
                           list( (blind1.key_id, reason1), ... ), \
                           (empty list1)  )

  ElseIf minting is done just-in-time, IS answers

    TRANSFER_TOKEN_ACCEPT( transaction_id, message, list_of_signed_blinds)

  Else IS queues blind to the mint and tells wallet to wait

    TRANSFER_TOKEN_DELAY( transaction_id, reason )

  Session is terminated.


  In case of delayed minting, mint processes request (signs blind with key_id)
  some time later and passes "signed blind"="blind coin" back to IS 


#5 Wallet gets coin back

* Wallet asks issuer service [was: FETCH_MINTED_REQUEST]

    TRANSFER_TOKEN_RESUME( transaction_id )

* IS either rejects finally

    TRANSFER_TOKEN_REJECT( transaction_id, reason,
                           list( (blind1.key_id, reason1), ... ), (empty list) )
 
  with reasons like "TID Unknown", "TID expired", "TID rejected", ...,
  or tells to wait longer

    TRANSFER_TOKEN_DELAY( transaction_id, reason )
    
  (question: what about key expiration while request is in mining queue)
  (oierw thinks: as long as the key is valid for minting when the request is made, we are good)

  or passes signed blinds to wallet Bob, must preserve order

    TRANSFER_TOKEN_ACCEPT( transaction_id, message, list_of_singed_blinds)
    
  Session terminates

* wallet checks if blind fits request id and if blind was correctly signed. 
  If not, delete blind and inform user (optional: inform issuer about error)
  (optional: if yes, inform issuer that he may delete the request)

* Wallet unblinds signed blind and yields coin  (or reblinds)


#6 Wallet to Wallet

Alice - sends a coin
Bob - receives the coin

* Prerequisites:
  * Wallet Alice locates Wallet Bob and sets up (secure) connection
  * Alice knows how much to send and tells her Wallet
  * Wallet Alice calculates a splitting of sum into coins (units) and
    creates a list of coins to send
  * Wallet Alice and Wallet Bob are synchronized to UTC (within some small margin of error)

* Alice fetches DSDB key at IS

    DSDB_KEY_REQUEST
    DSDB_KEY_PASS(keycertificate)

* Wallet Alice sends obfuscated blanks (coins without signature and with serial
  encrypted for DSDB) with the serial to Wallet Bob (Wallet Alice now needs to wait a while)

  {
      standard identifier = http://opencoin.org/OpenCoinProtocol/1.0
      currency identifier = http://opencent.net/OpenCent 
      denomination        = denomination
      key identifier      = key_id(signing key)
      serial              = base64(encrypt(ALG,pub-key-of-DSDB, serial))
  }

     BLANK_PRESENT( dsdb_keycertificate list(blank1, blank2, ...) )

* Wallet Bob check:

  * Wallet Bob validates the blanks
    - do we have the "currency description document"
    - do we trust the issuer (do we have a valid public key)
    - checks blanks against cdd

  * If blanks are invalid, the transfer is declined by Wallet Bob
    (later: cdd transfer between wallets)

  * Wallet Bob shows proposed transfer to Bob

  * Bob decides whether to 
    - accept transfer (trust issuer, enough currency)
    - accept transfer without double spending checking
    - decline transfer

      BLANK_REJECT( list( (encrypted_serial_blank1, "Reason1"), ... ) )
      BLANK_REJECT( emptylist, "Reason")

if DSDB is required (normal case):

    * Wallet Bob prepares for coin exchange with IS, by creating blanks of same sum (see #3)

    * Wallet Bob DSDB lookup
      - parse cdd for issuer service location
      - parse blanks for necessary minting key ids
      - start session with authenticated issuer service (IS) (secured and authenticated by transport layer, e.g. SSL)
        - get all missing minting key certs (MINTING_KEY_FETCH_KEYID)
        - IS sends key certs or rejects a key id (unknown, outdated) (MINTING_KEY_PASS/FAILURE)
        - lock list of encrypted coin serial numbers at IS (DSDB) 
            LOCK_COIN_REQUEST( DSDB_key_key_id, transaction_id,
                               list( (key_identifier1, encrypted_serial1), ... ) )

        - IS either accepts with locking time or rejects with list of rejected serials + reason (locked, spent) 
            If all coins lock:
               LOCK_COIN_ACCEPT(transaction_id, lock_expires)
            If some coins cannot lock, no coins are locked.
               LOCK_COIN_FAILURE(transaction_id, list( (key_identifier1, encrypted_serial1, "Reason1"), ...))

                     Reasons:
                          
                          Key ID of DSDB is unknown or expired       Permanant
                          Key ID of blank is unknown or expired      Permanant
                          Decryption of serial failed                Permanant
                          Serial already spent                       Permanant
                          Serial locked (not spent)                  Temporary


      (this part pauses, session is kept)

* Wallet Bob tells Wallet Alice accept or reject with reason (unknown, outdated, locked, spent) for each rejected blank
  (if one blank is rejected the whole transfer has to be rejected) (future: bob signs receipt)

      BLANK_FAILURE( list( (encrypted_serial_blank1, "Reason1"), ...))
      BLANK_FAILURE( emptylist, "Reason")

      BLANK_ACCEPT

      Note: After BLANK_ACCEPT, a BLANK_REJECT(emptylist, "Reason) can be given to abort the transaction until
            COIN_SPEND is sent
            
* Wallet Alice sends coins to Wallet Bob (this time including their clear serial and signature)
  
    COIN_SPEND( list(coin1, ...) )

* Wallet Bob checks that the coins match the blanks and that signatures are valid

* Wallet Bob accepts transaction or rejects with reason (unknown, invalid) for each rejected coin

     COIN_REJECT( list( (coin1, "Reason1") ) )
     COIN_REJECT( emptylist, "Reason")

     COIN_ACCEPT

* Wallet Bob terminates session with Wallet Alice

    (in case of rejection Wallet Alice needs to do emergency meassures, quickly trying to exchange coins with IS 
     itself etc.)


if DSDB is required (normal case):
    
    * in case of reject in the checking phase delete the blanks, otherwise
        UNLOCK_COIN_REQUEST(transaction_id)

    * Wallet Bob sends buy request (blanks + coins)

    
        TRANSFER_TOKEN_REQUEST( transaction_id, list_of_options, "", \
                                list_of_blinds, list_of_coins )


    (the transaction_id has to be the same as in the lock request, and 
     the list of coins has to match the list of locked coins. You can't
     have split / partial redemption)

    * IS has to check if sum of blanks and coins are equal

    * (Wallet Bob and IS continue as in #4 and #8)



#7 Redeeming Coins 

* Wallet locks serials at IS (see above LOCK_COIN)

* Wallet sends coins + target to IS [was: REDEEM_COINS_REQUEST]

   TRANSFER_TOKEN_REQUEST( transaction_id, list_of_options, target, \
                           (empty list), list_of_coins )

    target may be an account and is of the form:
        MINT_REQUEST=#base64(request_id)
        ONLINE_BANKING_ACCOUNT=#string(account_identifier)
        and so on... to be defined with relationship between IS and individual

* continue with #8

* Send money to target


#8 Accepting coins

* IS checks:
    - if minting keys are still valid
    - if serial is still valid (against DSDB)
    - if signature is valid
    - if target is valid

* IS rejects with reason (key id unknown, coin outdated, coin spent, signature
  invalid) per coin or [was: REDEEM_COINS_REJECT]

    TRANSFER_TOKEN_REJECT( transaction_id, reason,
                           (empty list), list( (coin1.key_id,  reason1), ... )  )

* (IS tries to service target, rejects with reason if not possible)

* IS enters serials into DSDB

* IS sends accept to Wallet [was: REDEEM_COINS_ACCEPT]

    TRANSFER_TOKEN_ACCEPT( transaction_id, message, (empty list))

