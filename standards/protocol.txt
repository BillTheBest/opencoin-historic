OpenCoin Project                                            N. Toedtmann
http://opencoin.org/                                         J. H. Baach
Category: Draft                                                 M. Ryden

                      OpenCoin Formats and Protocol

Status of this Memo

   This draft is work in heavy progress. Do not consider it's content
   stable in any sense as long as this note is present. Get in touch
   with opencoin.org [1] and fetch a recent copy [2].
   

Copyright Notice

   Copyright (c) N. Toedtmann, J. H. Baach, M. Ryden (2008).


Abstract

   This document describes the OpenCoin protocol which seeks to
   implement David Chaum's concept of "untraceable payments" [3].


ToDo

   - do the stuff in ./TODO
   - licence of this document?
   - "Introduction"
   - replace "COIN_SPEND" with "TRANSFER_TOKEN"
   - decide whether the protocol atoms are tokens or lists of tokens
   - throw out reduntant "TRANSFER_TOKEN" explanatoins
   - add authentication and authorization, at least for "target"
     when mintig
   - add mandatory trusted channel (Bluetooth, TLS)


Table of Contents

   1. Introduction
   2. General guidelines
   3. The OpenCoin protocol
      3.1.  Issuer setup
      3.2.  Wallet setup
      3.3.  Wallet creates blanks
      3.3.5."TRANSFER_TOKEN": A generic wallet-issuer request
      3.4.  Wallet send minting request to issuer  
      3.5.  Wallet gets token back
      3.6.  Wallet to wallet
      3.7.  Redeeming tokens
   4. References


1. Introduction

[ToDo]


2. General guidelines

[ToDo]


3. The OpenCoin protocol
 
3.1 Issuer setup

* issuer generates master key pair (ALG,pM,sM)

* issuer sets up "currency description document" = CDD (like a root certificate)

   {
     standard version             = http://opencoin.org/OpenCoinProtocol/1.0
     currency identifier          = http://opencent.net/OpenCent
     short currency identifier    = OC 
     issuer service location      = opencoin://issuer.opencent.net:8002
     denominations                = strlist(1, 2, 5, 10, 20, 50, 100, 200, 500, 1000)  #list of strings seperated by commas
     issuer cipher suite          = HASH-ALG, SIGN-ALG, BLINDING-ALG
     issuer public master key     = base64(pM)
     
     issuer                       = base64(hash(pM))
     base64(sig(sM,hash(content part)))
   }

   (question: is the "short currency identifier" needed?)
   (question: "not use after")
   (future: add additionial signatures, e.g. from wallet software vendors (set up in containers already))

* issuer publishes CDD at "currency identifier" URL

* mint (regularily) creates keypairs (pP,sP) for all denominations and id(p).
  Master key holder generates keys certificate

  {
    key identifier      = base64(hash(pP))
    currency identifier = http://opencent.net/OpenCent
    denomination        = denomination
    not_before          = TIME(...)
    key_not_after       = TIME(...)
    token_not_after      = TIME(...)
    public key          = base64(pP)

    issuer              = base64(hash(pM))
    base64(sig(sM, hash(content part)))
  }

  
  Questions:
  * CDD? (What does this question mean?)

* issuer creates DSDB keypair (pD,sD)

  {
    key identifier   = base64(hash(pD))
    not_before       = TIME(...)
    not_after        = TIME(...)
    cipher           = ENCRYPTION-ALG
    public key       = base64(pD)

    issuer           = base64(hash(pM))
    signature        = base64(sig(sM, hash(content part)))

    signer           = base64(hash(pM))
    signature        = base64(sig(sM, hash(content part)))
  }   


* issuer fires up issuer service (=IS) at <opencoin://issuer.opencent.net:8002>


3.2 Wallet setup

* fetch "currency description document" from issuer


3.3 Wallet creates blanks

* Wallet: fetches current public minting keys for denomination

Wallet:
    MINTING_KEY_FETCH_DENOMINATION(denomination) or MINTING_KEY_FETCH_KEYID(key_id)
IS:
    MINTING_KEY_PASS(keycertificate) or MINTING_KEY_FAILURE(reason)

* Wallet: creates blank according to CDD:

  {
      standard identifier = http://opencoin.org/OpenCoinProtocol/1.0
      currency identifier = http://opencent.net/OpenCent 
      denomination        = denomination
      key identifier      = key_id(signing key)
      serial              = base64(128bit random number)
  }


* Wallet: create random r, calculate 

    blind = blinding(r, pub_minting_key, hash(blank))
 
  Calculate a collision-free random transaction ID (128 bit)

  Keep (r, blank, blind) in mind. 
  

3.3.5 "TRANSFER_TOKEN": A generic wallet-issuer request

The atom for this transaction is a list of tokens - if one of the tokens /blanks
fail, the whole transaction fails.

* Send 
   
   TRANSFER_TOKEN_REQUEST( transaction_id, list_of_options, target, \
                            list_of_blinds, list_of_tokens )
    
   XXX list of blinds -> list of (blinds + denomination key/id)
   XXX both sides need to enforce correctness of 


  to IS (issuer service), where 
  * transaction_id is a base64(random(128bit)) referencing this transaction
    e.g. for later resume after an abort. 
  * option may contain variable=value pairs like "JITM=mandatory".
  * target 
    * value(list_of_blinds) = value(list_of_tokens): empty
    * value(list_of_blinds) > value(list_of_tokens): payment reference
    * value(list_of_blinds) < value(list_of_tokens): account reference

  For now, only 'pure' transactions are allowed, so one of these must 
  be empty:
  * target        : token exchange (value(list_of_blinds) = value(list_of_tokens))
  * list_of_tokens : mint request
  * list_of_blinds: redemption

  If at least one of the blinds or tokens is rejected, the issuer answers

    TRANSFER_TOKEN_REJECT( transaction_id, reason,
                           list( (blind1.key_id, reason1), ... ), \
                           list( (token1.key_id,  reason1), ... )  )

  where "reason" may be some general failure like "500 minting not available".
  If the request is accepted with no delay, IS answers

    TRANSFER_TOKEN_ACCEPT( transaction_id, message, list_of_singed_blinds)

  (with list_of_singed_blinds empty if no minting was required)
  If minting was requested and acccepted but postponed, IS answers

    TRANSFER_TOKEN_DELAY( transaction_id, message )

  In this case, the wallet can fetch the signed blinds later by 

    TRANSFER_TOKEN_RESUME( transaction_id )


3.4 Wallet send minting request to issuer  

* Send [was: MINT_REQUEST]

    TRANSFER_TOKEN_REQUEST( transaction_id, list_of_options, target, \
                            list_of_blinds, (empty list) )

  to issuer service

* Issuer: if request will not be minted (e.g., "Bad Key ID" if the key_id
  is not current):

    TRANSFER_TOKEN_REJECT( transaction_id, reason,
                           list( (blind1.key_id, reason1), ... ), \
                           (empty list1)  )

  ElseIf minting is done just-in-time, IS answers

    TRANSFER_TOKEN_ACCEPT( transaction_id, message, list_of_signed_blinds)

  Else IS queues blind to the mint and tells wallet to wait

    TRANSFER_TOKEN_DELAY( transaction_id, reason )

  Session is terminated.


  In case of delayed minting, mint processes request (signs blind with key_id)
  some time later and passes "signed blind"="blind token" back to IS 


3.5 Wallet gets token back

* Wallet asks issuer service [was: FETCH_MINTED_REQUEST]

    TRANSFER_TOKEN_RESUME( transaction_id )

* IS either rejects finally

    TRANSFER_TOKEN_REJECT( transaction_id, reason,
                           list( (blind1.key_id, reason1), ... ), (empty list) )
 
  with reasons like "TID Unknown", "TID expired", "TID rejected", ...,
  or tells to wait longer

    TRANSFER_TOKEN_DELAY( transaction_id, reason )
    
  (question: what about key expiration while request is in mining queue)
  (oierw thinks: as long as the key is valid for minting when the request is made, we are good)

  or passes signed blinds to wallet Bob, must preserve order

    TRANSFER_TOKEN_ACCEPT( transaction_id, message, list_of_singed_blinds)
    
  Session terminates

* wallet checks if blind fits request id and if blind was correctly signed. 
  If not, delete blind and inform user (optional: inform issuer about error)
  (optional: if yes, inform issuer that he may delete the request)

* Wallet unblinds signed blind and yields token  (or reblinds)


3.6 Wallet to wallet

Alice - sends a token
Bob   - receives the token

Note: 
  The request type "COIN_SPEND" may get exchanged by "TRANSFER_TOKEN_REQUEST"
  of type "redeem" in future versions of this protocol.

* Prerequisites
  * Wallet Alice locates Wallet Bob and sets up (secure) connection
  * Alice knows how much to send and tells her Wallet
  * Wallet Alice calculates a splitting of sum into tokens (units)
    and reates a list of tokens to send
  * Wallet Alice and Wallet Bob are synchronized to UTC (within some small 
    margin of error)


* [ToDo] Handshake


* Wallet Alice announces sum of tokens she wishes to spend for a certain
  prupose=target, wallet Bob decides if it is going to accept them:

    A:      SUM_ANNOUNCE( transaction_id, sum, target )
    B:      SUM_ACCEPT( transaction_id )
        or  SUM_REJECT( transaction_id, "Reason" )


* Wallet Alice sends tokens to Wallet Bob (this time including their clear 
  serial and signature)
  
    A:      COIN_SPEND( transaction_id, list(token1, ...) )


* Wallet Bob checks if the sum of their values matches the announced sum, if 
  they are valid and (if the former tests do not fail) tries itself to spent
  the tokens at the issuer with a TRANSFER_TOKEN_REQUEST of type "redeem" or
  "exchange", using a new, different transaction_id. If one of these fail,
  wallet Bob rejects the request it with a reason/reasons, otherwise accepts
  them:

    B:      COIN_REJECT( transaction_id, list( (tokenN, "ReasonN") ) )
        or  COIN_REJECT( transaction_id, emptylist, "Reason")
        or  COIN_ACCEPT( transaction_id )

  Possible reasons are "unknown", "invalid" ... [ToDo].

  In case of rejection, wallet Alice itself should immediatly exchange these 
  tokens at the issuer as an emergancy countermeasure against token theft.

  In case of acceptance, wallet Alice must delete all instances of the spent
  tokens.


3.7 Redeeming tokens 

* Wallet sends tokens + target to IS

    W:  TRANSFER_TOKEN_REQUEST(
            transaction_id, list_of_options, target, (empty list), list_of_tokens 
        )

  target may be an account and is of the form:

        MINT_REQUEST=#base64(request_id)
        ONLINE_BANKING_ACCOUNT=#string(account_identifier)
        and so on... to be defined with relationship between IS and individual


* IS checks if tokens and target are valid
    - if minting keys are still valid (XXX token has not expired)
    - if serial is still valid (against DSDB)
    - if signature is valid

  If not, IS rejects with reason (key id unknown, token outdated, token spent, 
  signature invalid) per token or sweeping

    IS: TRANSFER_TOKEN_REJECT( 
            transaction_id, reason, (empty list), list( (token1.key_id,  reason1), ... )  )
        )

  If tokens and target are valid, IS enters the serials of the tokens into the
  DSDB, servers the target and replies

    IS: TRANSFER_TOKEN_ACCEPT( 
            transaction_id, message, (empty list)
        )


4. References

[1]  The OpenCoin project <http://opencoin.org/>

[2]  The OpenCoin project, "OpenCoin protocol v1.0"
     <https://trac.opencoin.org/trac/opencoin/browser/trunk/standards/protocol.txt>

[3]  David Chaum, "Blind signatures for untraceable payments", Advances in 
     Cryptology - Crypto '82, Springer-Verlag (1983), 199-203.
