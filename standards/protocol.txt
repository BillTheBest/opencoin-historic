OpenCoin Project                                            N. Toedtmann
http://opencoin.org/                                         J. H. Baach
Category: Draft                                                 M. Ryden

                      OpenCoin Formats and Protocol

Status of this Memo

   This draft is work in heavy progress. Do not consider it's content
   stable in any sense as long as this note is present. Get in touch
   with opencoin.org [1] and fetch a recent copy [2].
   

Copyright Notice

   Copyright (c) N. Toedtmann, J. H. Baach, M. Ryden (2008).


Abstract

   This document describes the OpenCoin protocol which seeks to
   implement David Chaum's concept of "untraceable payments" [3].


ToDo

   - do the stuff in ./TODO
   - licence of this document?
   - "Introduction"
   - replace "coin" with "token"
   - decide whether the protocol atoms are tokens or lists of tokens
   - throw out reduntant "TRANSFER_TOKEN" explanatoins


Table of Contents

   1. Introduction
   2. General guidelines
   3. The OpenCoin protocol
      3.1.  Issuer setup
      3.2.  Wallet setup
      3.3.  Wallet creates blanks
      3.3.5."TRANSFER_TOKEN": A generic wallet-issuer request
      3.4.  Wallet send minting request to issuer  
      3.5.  Wallet gets coin back
      3.6.  Wallet to Wallet
      3.7.  Redeeming Coins 
      3.8.  Accepting coins
   4. References


1. Introduction

[ToDo]


2. General guidelines

[ToDo]


3. The OpenCoin protocol
 
3.1 Issuer setup

* issuer generates master key pair (ALG,pM,sM)

* issuer sets up "currency description document" = CDD (like a root certificate)

   {
     standard version             = http://opencoin.org/OpenCoinProtocol/1.0
     currency identifier          = http://opencent.net/OpenCent
     short currency identifier    = OC 
     issuer service location      = opencoin://issuer.opencent.net:8002
     denominations                = strlist(1, 2, 5, 10, 20, 50, 100, 200, 500, 1000)  #list of strings seperated by commas
     issuer cipher suite          = HASH-ALG, SIGN-ALG, BLINDING-ALG
     issuer public master key     = base64(pM)
     
     issuer                       = base64(hash(pM))
     base64(sig(sM,hash(content part)))
   }

   (question: is the "short currency identifier" needed?)
   (question: "not use after")
   (future: add additionial signatures, e.g. from wallet software vendors (set up in containers already))

* issuer publishes CDD at "currency identifier" URL

* mint (regularily) creates keypairs (pP,sP) for all denominations and id(p).
  Master key holder generates keys certificate

  {
    key identifier      = base64(hash(pP))
    currency identifier = http://opencent.net/OpenCent
    denomination        = denomination
    not_before          = TIME(...)
    key_not_after       = TIME(...)
    coin_not_after      = TIME(...)
    public key          = base64(pP)

    issuer              = base64(hash(pM))
    base64(sig(sM, hash(content part)))
  }

  
  Questions:
  * CDD? (What does this question mean?)

* issuer creates DSDB keypair (pD,sD)

  {
    key identifier   = base64(hash(pD))
    not_before       = TIME(...)
    not_after        = TIME(...)
    cipher           = ENCRYPTION-ALG
    public key       = base64(pD)

    issuer           = base64(hash(pM))
    signature        = base64(sig(sM, hash(content part)))

    signer           = base64(hash(pM))
    signature        = base64(sig(sM, hash(content part)))
  }   


* issuer fires up issuer service (=IS) at <opencoin://issuer.opencent.net:8002>


3.2 Wallet setup

* fetch "currency description document" from issuer


3.3 Wallet creates blanks

* Wallet: fetches current public minting keys for denomination

Wallet:
    MINTING_KEY_FETCH_DENOMINATION(denomination) or MINTING_KEY_FETCH_KEYID(key_id)
IS:
    MINTING_KEY_PASS(keycertificate) or MINTING_KEY_FAILURE(reason)

* Wallet: creates blank according to CDD:

  {
      standard identifier = http://opencoin.org/OpenCoinProtocol/1.0
      currency identifier = http://opencent.net/OpenCent 
      denomination        = denomination
      key identifier      = key_id(signing key)
      serial              = base64(128bit random number)
  }


* Wallet: create random r, calculate 

    blind = blinding(r, pub_minting_key, hash(blank))
 
  Calculate a collision-free random transaction ID (128 bit)

  Keep (r, blank, blind) in mind. 
  

3.3.5 "TRANSFER_TOKEN": A generic wallet-issuer request

The atom for this transaction is a list of coins - if one of the coins /blanks
fail, the whole transaction fails.

* Send 
   
   XXX target might be an attack target, maybe insert authentication
   XXX make the transaction type explicit?

   TRANSFER_TOKEN_REQUEST( transaction_id, list_of_options, target, \
                            list_of_blinds, list_of_coins )
    
   XXX list of blinds -> list of (blinds + denomination key/id)
   XXX both sides need to enforce correctness of 


  to IS (issuer service), where 
  * transaction_id is a base64(random(128bit)) referencing this transaction
    e.g. for later resume after an abort. 
  * option may contain variable=value pairs like "JITM=mandatory".
  * target 
    * value(list_of_blinds) = value(list_of_coins): empty
    * value(list_of_blinds) > value(list_of_coins): payment reference
    * value(list_of_blinds) < value(list_of_coins): account reference

  For now, only 'pure' transactions are allowed, so one of these must 
  be empty:
  * target        : coin exchange (value(list_of_blinds) = value(list_of_coins))
  * list_of_coins : mint request
  * list_of_blinds: redemption

  If at least one of the blinds or coins is rejected, the issuer answers

    TRANSFER_TOKEN_REJECT( transaction_id, reason,
                           list( (blind1.key_id, reason1), ... ), \
                           list( (coin1.key_id,  reason1), ... )  )

  where "reason" may be some general failure like "500 minting not available".
  If the request is accepted with no delay, IS answers

    TRANSFER_TOKEN_ACCEPT( transaction_id, message, list_of_singed_blinds)

  (with list_of_singed_blinds empty if no minting was required)
  If minting was requested and acccepted but postponed, IS answers

    TRANSFER_TOKEN_DELAY( transaction_id, message )

  In this case, the wallet can fetch the signed blinds later by 

    TRANSFER_TOKEN_RESUME( transaction_id )


3.4 Wallet send minting request to issuer  

* Send [was: MINT_REQUEST]

    TRANSFER_TOKEN_REQUEST( transaction_id, list_of_options, target, \
                            list_of_blinds, (empty list) )

  to issuer service

* Issuer: if request will not be minted (e.g., "Bad Key ID" if the key_id
  is not current):

    TRANSFER_TOKEN_REJECT( transaction_id, reason,
                           list( (blind1.key_id, reason1), ... ), \
                           (empty list1)  )

  ElseIf minting is done just-in-time, IS answers

    TRANSFER_TOKEN_ACCEPT( transaction_id, message, list_of_signed_blinds)

  Else IS queues blind to the mint and tells wallet to wait

    TRANSFER_TOKEN_DELAY( transaction_id, reason )

  Session is terminated.


  In case of delayed minting, mint processes request (signs blind with key_id)
  some time later and passes "signed blind"="blind coin" back to IS 


3.5 Wallet gets coin back

* Wallet asks issuer service [was: FETCH_MINTED_REQUEST]

    TRANSFER_TOKEN_RESUME( transaction_id )

* IS either rejects finally

    TRANSFER_TOKEN_REJECT( transaction_id, reason,
                           list( (blind1.key_id, reason1), ... ), (empty list) )
 
  with reasons like "TID Unknown", "TID expired", "TID rejected", ...,
  or tells to wait longer

    TRANSFER_TOKEN_DELAY( transaction_id, reason )
    
  (question: what about key expiration while request is in mining queue)
  (oierw thinks: as long as the key is valid for minting when the request is made, we are good)

  or passes signed blinds to wallet Bob, must preserve order

    TRANSFER_TOKEN_ACCEPT( transaction_id, message, list_of_singed_blinds)
    
  Session terminates

* wallet checks if blind fits request id and if blind was correctly signed. 
  If not, delete blind and inform user (optional: inform issuer about error)
  (optional: if yes, inform issuer that he may delete the request)

* Wallet unblinds signed blind and yields coin  (or reblinds)


3.6 Wallet to Wallet

Alice - sends a coin
Bob - receives the coin

* Prerequisites:
  * Wallet Alice locates Wallet Bob and sets up (secure) connection
  * Alice knows how much to send and tells her Wallet
  * Wallet Alice calculates a splitting of sum into coins (units) and
    creates a list of coins to send
  * Wallet Alice and Wallet Bob are synchronized to UTC (within some small margin of error)

* Wallet Alice sends coins to Wallet Bob (this time including their clear serial and signature)
  
    COIN_SPEND( list(coin1, ...) )

* Wallet Bob checks that the coins match the blanks and that signatures are valid

* Wallet Bob accepts transaction or rejects with reason (unknown, invalid) for each rejected coin

     COIN_REJECT( list( (coin1, "Reason1") ) )
     COIN_REJECT( emptylist, "Reason")

     COIN_ACCEPT

* Wallet Bob terminates session with Wallet Alice

    (in case of rejection Wallet Alice needs to do emergency meassures, quickly trying to exchange coins with IS 
     itself etc.)

    * Wallet Bob sends buy request (blanks + coins)

    
        TRANSFER_TOKEN_REQUEST( transaction_id, list_of_options, "", \
                                list_of_blinds, list_of_coins )


    * IS has to check if sum of blanks and coins are equal

    * (Wallet Bob and IS continue as in #4 and #8)


3.7 Redeeming Coins 

* Wallet locks serials at IS (see above LOCK_COIN)

* Wallet sends coins + target to IS [was: REDEEM_COINS_REQUEST]

   TRANSFER_TOKEN_REQUEST( transaction_id, list_of_options, target, \
                           (empty list), list_of_coins )

    target may be an account and is of the form:
        MINT_REQUEST=#base64(request_id)
        ONLINE_BANKING_ACCOUNT=#string(account_identifier)
        and so on... to be defined with relationship between IS and individual

* continue with 3.8

* Send money to target


3.8 Accepting coins

* IS checks:
    - if minting keys are still valid (XXX coin has not expired)
    - if serial is still valid (against DSDB)
    - if signature is valid
    - if target is valid

* IS rejects with reason (key id unknown, coin outdated, coin spent, signature
  invalid) per coin or [was: REDEEM_COINS_REJECT]

    TRANSFER_TOKEN_REJECT( transaction_id, reason,
                           (empty list), list( (coin1.key_id,  reason1), ... )  )

* (IS tries to service target, rejects with reason if not possible)

* IS enters serials into DSDB

* IS sends accept to Wallet [was: REDEEM_COINS_ACCEPT]

    TRANSFER_TOKEN_ACCEPT( transaction_id, message, (empty list))


4. References

[1]  The OpenCoin project <http://opencoin.org/>

[2]  The OpenCoin project, "OpenCoin protocol v1.0"
     <https://trac.opencoin.org/trac/opencoin/browser/trunk/standards/protocol.txt>

[3]  David Chaum, "Blind signatures for untraceable payments", Advances in 
     Cryptology - Crypto '82, Springer-Verlag (1983), 199-203.
