OpenCoin 

How the wallet creates a coin and communicates with an issuer
=============================================================
 
#1 issuer setup

* issuer generates master key pair (ALG,pM,sM)

* issuer sets up "currency description document" = CDD (like a root certificate)

   {
     standard version             = http://opencoin.org/OpenCoinProtocol/1.0
     currency identifier          = http://opencent.net/OpenCent
     short currency identifier    = OC 
     issuer service location      = opencoin://issuer.opencent.net:8002
     denominations                = 1, 2, 5, 10, 20, 50, 100, 200, 500, 1000  #list of strings seperated by commas
     issuer cipher suite          = HASH-ALG, SIGN-ALG, BLINDING-ALG
     issuer public master key     = base64(pM)
     
     issuer                       = Hash(pM)
     base64(sig(sM,hash(content part)))
   }

   (question: is the "short currency identifier" needed?)
   (question: "not use after", "random collision free serial"?)
   (future: add additionial signatures, e.g. from wallet software vendors)

* issuer publishes CDD at "currency identifier" URL

* mint (regularily) creates keypairs (p,s) for all denominations and id(p).
  Master key holder generates keys certificate

  {
    key identifier      = base64(id(p))
    currency identifier = http://opencent.net/OpenCent
    denomination        = denomination
    not_before          = TIME(...)
    key_not_after       = TIME(...)
    coin_not_after      = TIME(...)
    public key          = base64(p)

    issuer              = Hash(pM)
    base64(sig(sM, hash(content part)))
  }

  
  Questions:
  * Time format:  YYYYMMDDHHMMSS  20071211144111 or SecondsSinceEpoch?
  * id() = sha256()?
  * CDD?

* issuer creates DSDB keypair (p,s)

  {
    key identifier   = base64(id(p))
    not_before       = TIME(...)
    not_after        = TIME(...)
    public key       = base64(p)

    issuer           = Hash(pM)
    signature        = base64(sig(sM, hash(content part)))

    signer           = Hash(pM)
    signature        = base64(sig(sM, hash(content part)))
  }   


* issuer fires up issuer service (=IS) at <opencoin://issuer.opencent.net:8002>



#2 wallet setup

* fetch "currency description document" from issuer


#3 wallet creates blanks

* Wallet: fetches current public minting keys for denomination

Wallet:  FETCH_MINTING_KEY {DENOMINATION #string(denomination)|KEYID #hexstring(key_id)}
    IS:      PASS_MINTING_KEY keycertificate
      or     FAIL_MINTING_KEY "Reason"

    (question: base64 response?)

* Wallet: creates blank according to CDD:

  {
      standard identifier = http://opencoin.org/OpenCoinProtocol/1.0
      currency identifier = http://opencent.net/OpenCent 
      denomination        = denomination
      key identifier      = key_id(signing key)
      serial              = base64(128bit random number)
  }


* Wallet: create random r, calculate 

    blind = blinding(r, pub_minting_key, hash(blank))
 
  Calculate a collision-free random request ID (128 bit)

  Keep (r, blank, blind) in mind. 
  
  
#4 wallet send minting request to issuer  

* Send 

    REQUEST_MINTING #base64(request_id) #hex_string(number_of_blinds) 
             #key_id(blind1) #base64(blind1)
             #key_id(blind2) #base64(blind2)[\r]\n

  to issuer service

* Issuer: if key_id is not current:

    REFUSE_MINTING #hex_string(number_of_rejected_blinds)
              #key_id(blind1) "Bad Key ID"
              #key_id(blind2) "Bad Key ID"[\r]\n

  Elif request will not be minted (e.g., payment not yet received):

    REFUSE_MINTING #hex_string(number_of_rejected_blinds)
                #key_id(blind1) "Some error message"
                #key_id(blind2) "Some error message"[\r]\n
  
  Else: IS passes (maybe asynchronous) request to mint and:
    ACKNOWLEDGE_MINTING #base64(request_id)[\r]\n

  Session is terminated.



  Mint processes request (signs blind with key_id)

  Mint passes "signed blind"="blind coin" back to IS 


#5 Wallet gets coin back

* Wallet asks issuer service "fetch_signed_blind request_id"

    FETCH_MINTED_BLINDS #base64(request_id)

* IS either rejects finally or temporarily

    FETCH_MINTED_FAILED #base64(request_id) "Reason"
    FETCH_MINTED_WAIT   #base64(request_id) "Reason"
 
    Possible failures: "Request ID Unknown", "Request ID expired", "Request ID rejected"
    Possible waits:    "Processing request"

  (question: what about key expiration while request is in mining queue)

  or passes signed blinds to wallet Bob, must preserve order

    PASS_MINTED_BLINDS #base64(request_id) #hex_string(number_of_blinds)
                 #base64(signature_of_blind1)
                 #base64(signature_of_blind2)[\r]\n

  Session terminates

* wallet checks if blind fits request id and if blind was correctly signed. 
  If not, delete blind and inform user (optional: inform issuer about error)
  (optional: if yes, inform issuer that he may delete the request)

* Wallet unblinds signed blind and yields coin  (or reblinds)


#6 Wallet to Wallet

Alice - sends a coin
Bob - receives the coin

* Prerequisites:
  * Wallet Alice locates Wallet Bob and sets up (secure) connection
  * Alice knows how much to send and tells her Wallet
  * Wallet Alice calculates a splitting of sum into coins (units) and
    creates a list of coins to send
  * Wallet Alice and Wallet Bob are synchronized to UTC (within some small margin of error)

* Alice fetches DSDB key at IS

    FETCH_DSDB_KEY
    PASS_DSDB_KEY keycertificate

* Wallet Alice sends obfuscated blanks (coins without signature and with serial
  encrypted for DSDB) with the serial to Wallet Bob (Wallet Alice now needs to wait a while)

  {
      standard identifier = http://opencoin.org/OpenCoinProtocol/1.0
      currency identifier = http://opencent.net/OpenCent 
      denomination        = denomination
      key identifier      = key_id(signing key)
      serial              = base64(encrypt(ALG,pub-key-of-DSDB, serial))
  }

     PRESENT_BLANK #hex_string(number_of_blanks)
       blank1[\r]\n
       blank2[\r]\n

* Wallet Bob check:

  * Wallet Bob validates the blanks
    - do we have the "currency description document"
    - do we trust the issuer (do we have a valid public key)
    - checks blanks against cdd

  * If blanks are invalid, the transfer is declined by Wallet Bob
    (later: cdd transfer between wallets)

  * Wallet Bob shows proposed transfer to Bob

  * Bob decides whether to 
    - accept transfer
    - accept transfer without double spending checking
    - decline transfer

      REFUSE_BLANK #hex_string(number_of_failures)
         #base64(ecrypted serial of blank1) "Why did we fail?!?"
         #base64(ecrypted serial of blank2) "Why did we fail?!?"[\r]\n

      REFUSE_BLANK #hex_string(0) "reason"  

  (Todo: Add reasons)

if DSDB is required (normal case):

    * Wallet Bob prepares for coin exchange with IS, by creating blanks of same sum (see #3)

    * Wallet Bob DSDB lookup
      - parse cdd for issuer service location
      - parse blanks for necessary minting key ids
      - start session with authenticated issuer service (IS) (secured and authenticated by transport layer, e.g. SSL)
        - create transaction id (two-party secret agreement (collision free))
          Possible example with https.
            USE_HTTPS_SESSIONID
            YES|NO
        - get all missing minting key certs (FETCH_MINTING_KEY)
        - IS sends key certs or rejects a key id (unknown, outdated) (PASS_MINTING_KEY/FAIL_MINTING_KEY)
        - lock list of encrypted coin serial numbers at IS (DSDB) 
            LOCK_COINS #key_id_of_DSDB #hex_string(transaction_id) #hex_string(#number_of_obfuscated_blanks)
                       #key_identifier1 #encrypted_serial1
                       #key_identifier2 #encrypted_serial2[\r]\n

        - IS either accepts with locking time or rejects with list of rejected serials + reason (locked, spent) 
            If all coins lock:
               LOCK_COINS_GRANTED #hex_string(transaction_id) TIME(lock_expires)
            If some coins cannot lock, no coins are locked.
               LOCK_COINS_FAILED #hex_sting(transaction_id) #hex_string(number_of_failures)
                                 #key_identifier1 #encrypted_serial1 "Reason 1"
                                 #key_identifier2 #encrypted_serial2 "Reason 2"[\r]\n

                     Reasons:
                          
                          Key ID of DSDB is unknown or expired       Permanant
                          Key ID of blank is unknown or expired      Permanant
                          Decryption of serial failed                Permanant
                          Serial already spent                       Permanant
                          Serial locked (not spent)                  Temporary


      (this part pauses, session is kept)

* Wallet Bob tells Wallet Alice accept or reject with reason (unknown, outdated, locked, spent) for each rejected blank
  (if one blank is rejected the whole transfer has to be rejected) (future: bob signs receipt)

      REFUSE_BLANK #hex_string(number_of_failures)
         #base64(ecrypted serial of blank1) "Why did we fail?!?"
         #base64(ecrypted serial of blank2) "Why did we fail?!?"[\r]\n

      REFUSE_BLANK #hex_string(0) "reason"  

      ACCEPT_BLANK

      Note: After ACCEPT_BLANK, a REFUSE_BLANK #hex_string(0) can be given to abort the transaction


* Wallet Alice sends coins to Wallet Bob (this time including their clear serial and signature)
  
    SPEND_COINS #hex_string(number_of_coins)
                #base64(coin1)
                #base64(coin2)[\r]\n

* Wallet Bob checks that the coins match the blanks and that signatures are valid

* Wallet Bob accepts transaction or rejects with reason (unknown, invalid) for each rejected coin

     REJECT_COIN #hex_string(number_of_coins)
                 #base64(coin1) "Reason"
                 #base64(coin2) "Reason"[\r]\n

     REJECT_COIN #hex_string(0) "Reason"

     ACCEPT_COIN

* Wallet Bob terminates session with Wallet Alice

    (in case of rejection Wallet Alice needs to do emergency meassures, quickly trying to exchange coins with IS 
     itself etc.)


if DSDB is required (normal case):
    
    * in case of reject in the checking phase delete the blanks, otherwise
        UNLOCK_COINS #hex_string(transaction_id)

    * Wallet Bob sends buy request (blanks + coins) (Wallet Bob continues as in #4 and #8)
        (REDEEM_COINS+REQUEST_MINT)

    * IS has to check if sum of blanks and coins are equal


#7 Redeeming Coins 

* Wallet locks serials at IS (see above LOCK_COINS)

* Wallet sends coins + target to IS
  
  - target can be an account
    REDEEM_COINS #hex_string(transaction_id) "#string(target)" #hex_string(number_of_coins)
                 #base64(coin1)
                 #base64(coin2)[\r]\n

    target is of the form:
        MINT_REQUEST=#base64(request_id)
        ONLINE_BANKING_ACCOUNT=#string(account_identifier)
        and so on... to be defined with relationship between IS and individual

* continue with #8

* Send money to target


#8 Accepting coins

* IS checks:
    - if minting keys are still valid
    - if serial is still valid (against DSDB)
    - if signature is valid
    - if target is valid

* IS rejects with reason (key id unknown, coin outdated, coin spent, signature invalid) per coin or 
     REJECT_COINS #hex_string(number_of_coins)
                  #base64(coin1) "Reason"
                  #base64(coin2) "Reason"[\r]\n

* (IS tries to service target, rejects with reason if not possible)

* IS enters serials into DSDB

* IS sends accept to Wallet
      ACCEPT_COINS

